#pragma once
#include "VapourSynth.h"
#include "Enumerations.vxx"
#include "Utility.vxx"

struct VideoFormat {
	field(ColorFamily, ColorFamilies::Undefined);
	field(SampleType, SampleTypes::Int);
	field(BitsPerSample, 0);
	field(BytesPerSample, 0);
	field(HorizontalSubsamplingFactor, 0);
	field(VerticalSubsamplingFactor, 0);
	field(PlaneCount, 0);

public:
	static constexpr auto LegacyLayoutOffset = sizeof(VSFormat::name) + sizeof(VSFormat::id);
	static constexpr auto IndeterminateID = 0;

public:
	static auto& ConstructIndeterminateInstance() {
		static constexpr auto IndeterminateInstance = VideoFormat{};
		return IndeterminateInstance;
	}

public:
	static auto& AdjustToStandardLayout(auto& FormatReference) {
		if constexpr (SubtypeOf<decltype(FormatReference), VideoFormat>)
			return FormatReference;
		else {
			auto FormatAddress = reinterpret_cast<const char*>(&FormatReference);
			return *reinterpret_cast<const VideoFormat*>(FormatAddress + LegacyLayoutOffset);
		}
	}
	static auto& AdjustToLegacyLayout(auto& FormatReference) {
		if constexpr (SubtypeOf<decltype(FormatReference), VSFormat>)
			return FormatReference;
		else {
			auto FormatAddress = reinterpret_cast<const char*>(&FormatReference);
			return *reinterpret_cast<const VSFormat*>(FormatAddress - LegacyLayoutOffset);
		}
	}

public:
	auto QueryID() const {
		auto NormalizedColorFamilyTag = static_cast<int>(ColorFamily) / 1000000;
		auto ColorFamilyFlag = (NormalizedColorFamilyTag & 0xF) << 28;
		auto SampleTypeFlag = (static_cast<int>(SampleType) & 0xF) << 24;
		auto BitdepthFlag = (BitsPerSample & 0xFF) << 16;
		auto HorizontalSubsamplingFlag = (HorizontalSubsamplingFactor & 0xFF) << 8;
		auto VerticalSubsamplingFlag = VerticalSubsamplingFactor & 0xFF;
		return ColorFamilyFlag | SampleTypeFlag | BitdepthFlag | HorizontalSubsamplingFlag | VerticalSubsamplingFlag;
	}
	auto IsSinglePrecision() const {
		return SampleType == SampleTypes::Float && BitsPerSample == 32;
	}
	auto IsRGB() const {
		return ColorFamily == ColorFamilies::RGB;
	}
	auto IsGray() const {
		return ColorFamily == ColorFamilies::Gray;
	}
	auto IsYUV() const {
		return ColorFamily == ColorFamilies::YUV;
	}
	auto Is444() const {
		return HorizontalSubsamplingFactor == 0 && VerticalSubsamplingFactor == 0;
	}
};

auto operator==(AnyOf<VideoFormat, VSFormat> auto&& LeftHandSideOperand, AnyOf<VideoFormat, VSFormat> auto&& RightHandSideOperand) {
	auto& PrimaryFormat = VideoFormat::AdjustToStandardLayout(LeftHandSideOperand);
	auto& ReferenceFormat = VideoFormat::AdjustToStandardLayout(RightHandSideOperand);
	return PrimaryFormat.QueryID() == ReferenceFormat.QueryID();
}

auto operator<=>(AnyOf<VideoFormat, VSFormat> auto&& LeftHandSideOperand, AnyOf<VideoFormat, VSFormat> auto&& RightHandSideOperand) {
	auto& PrimaryFormat = VideoFormat::AdjustToStandardLayout(LeftHandSideOperand);
	auto& ReferenceFormat = VideoFormat::AdjustToStandardLayout(RightHandSideOperand);
	return PrimaryFormat.QueryID() <=> ReferenceFormat.QueryID();
}

struct AudioFormat {
	//Placeholder for API v4.
};

struct VideoInfo {
	field(Format, VideoFormat{});
	field(FrameRateNumerator, 0_i64);
	field(FrameRateDenominator, 0_i64);
	field(Width, 0);
	field(Height, 0);
	field(FrameCount, 0);

public:
	static decltype(auto) AdjustToLegacyLayout(auto& MetadataReference, auto Core) {
		if constexpr (SubtypeOf<decltype(MetadataReference), VSVideoInfo>)
			return MetadataReference;
		else {
			auto& AnchoredFormat = Core.Query(MetadataReference.Format);
			return VSVideoInfo{
				.format = AnchoredFormat.QueryID() == VideoFormat::IndeterminateID ? nullptr : &VideoFormat::AdjustToLegacyLayout(AnchoredFormat),
				.fpsNum = MetadataReference.FrameRateNumerator, .fpsDen = MetadataReference.FrameRateDenominator,
				.width = MetadataReference.Width, .height = MetadataReference.Height, .numFrames = MetadataReference.FrameCount, .flags = 0
			};
		}
	}

public:
	auto WithConstantDimensions() const {
		return Width != 0 && Height != 0;
	}
	auto WithConstantFormat() const {
		return Format.QueryID() != VideoFormat::IndeterminateID;
	}
};

struct FlattenedVideoInfo : VideoFormat {
	field(FrameRateNumerator, 0_i64);
	field(FrameRateDenominator, 0_i64);
	field(Width, 0);
	field(Height, 0);
	field(FrameCount, 0);

public:
	auto WithConstantDimensions() const {
		return Width != 0 && Height != 0;
	}
	auto WithConstantFormat() const {
		return QueryID() != IndeterminateID;
	}
};

struct AudioInfo {
	//Placeholder for API v4.
};

struct PluginInfo {
	field(Namespace, ""s);
	field(Identifier, ""s);
	field(Description, ""s);
};

struct CoreInfo {
	field(Version, ""sv);
	field(CoreVersion, 0);
	field(APIVersion, 0);
	field(ThreadCount, 0);
	field(MaxFrameBufferSize, 0_i64);
	field(UsedFrameBufferSize, 0_i64);
};