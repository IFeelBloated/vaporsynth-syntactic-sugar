#pragma once
#include "Utility.vxx"
#include "Globals.vxx"

using VSLogHandle = struct {};

template<typename ManagedType>
struct Owner {
	field(Handle, static_cast<ManagedType*>(nullptr));

protected:
	using HandleType = const ManagedType*;

public:
	static constexpr auto NullHandle = static_cast<HandleType>(nullptr);

public:
	Owner() = default;
	Owner(ExplicitlyConvertibleTo<HandleType> auto&& Descriptor) {
		auto ManagedHandle = static_cast<HandleType>(Forward(Descriptor));
		this->Handle = Utility::PointerDropQualifiers(ManagedHandle);
	}

public:
	Owner(const Owner& OtherOwner) {
		*this = OtherOwner;
	}
	Owner(Owner&& OtherOwner) {
		*this = std::move(OtherOwner);
	}
	auto& operator=(const Owner& OtherOwner) {
		if (this != &OtherOwner) {
			this->ReleaseHandle();
			this->Handle = OtherOwner.CloneHandle();
		}
		return *this;
	}
	auto& operator=(Owner&& OtherOwner) {
		if (this != &OtherOwner)
			std::swap(this->Handle, OtherOwner.Handle);
		return *this;
	}

public:
	~Owner() {
		this->ReleaseHandle();
	}

public:
	auto IsEmpty() const {
		return Handle == NullHandle;
	}
	auto Leak() {
		auto TransferredHandle = Handle;
		Handle = nullptr;
		return Utility::PointerAddConstQualifier(TransferredHandle);
	}
	auto Observe() const {
		return Utility::PointerAddConstQualifier(Handle);
	}

protected:
	auto CloneHandle() const {
		if constexpr (SubtypeOf<HandleType, const VSFrameRef*>)
			return Utility::PointerDropQualifiers(VaporGlobals::API->cloneFrameRef(Handle));
		if constexpr (SubtypeOf<HandleType, const VSNodeRef*>)
			return VaporGlobals::API->cloneNodeRef(Handle);
		if constexpr (SubtypeOf<HandleType, const VSFuncRef*>)
			return VaporGlobals::API->cloneFuncRef(Handle);
	}
	auto ReleaseHandle() {
		if constexpr (SubtypeOf<HandleType, const VSFrameRef*>)
			VaporGlobals::API->freeFrame(Handle);
		if constexpr (SubtypeOf<HandleType, const VSNodeRef*>)
			VaporGlobals::API->freeNode(Handle);
		if constexpr (SubtypeOf<HandleType, const VSFuncRef*>)
			VaporGlobals::API->freeFunc(Handle);
	}
};

template<typename ManagedType, auto Managed>
struct ExclusiveOwner {
	field(Handle, static_cast<ManagedType*>(nullptr));

private:
	using HandleType = const ManagedType*;

public:
	ExclusiveOwner() = default;
	ExclusiveOwner(ExplicitlyConvertibleTo<HandleType> auto&& Descriptor) {
		auto ManagedHandle = static_cast<HandleType>(Forward(Descriptor));
		this->Handle = Utility::PointerDropQualifiers(ManagedHandle);
	}

public:
	ExclusiveOwner(const ExclusiveOwner&) = delete;
	ExclusiveOwner(ExclusiveOwner&&) = delete;
	auto& operator=(const ExclusiveOwner&) = delete;
	auto& operator=(ExclusiveOwner&&) = delete;

public:
	~ExclusiveOwner() requires (Managed == false) {
		if (this->Handle != nullptr)
			this->ReleaseHandle();
	}
	~ExclusiveOwner() = default;

public:
	auto Leak() {
		auto TransferredHandle = Handle;
		Handle = nullptr;
		return Utility::PointerAddConstQualifier(TransferredHandle);
	}

private:
	auto ReleaseHandle() {
		if constexpr (SubtypeOf<HandleType, const VSMap*>)
			VaporGlobals::API->freeMap(Handle);
		if constexpr (auto MangledLoggerID = reinterpret_cast<std::intptr_t>(Handle); SubtypeOf<HandleType, const VSLogHandle*>)
			VaporGlobals::API->removeMessageHandler(~static_cast<int>(MangledLoggerID));
	}
};