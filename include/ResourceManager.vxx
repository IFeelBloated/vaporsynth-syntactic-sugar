#pragma once
#include "Utility.vxx"
#include "Globals.vxx"

using VSLogHandle = struct {};

template<typename ManagedType>
struct Owner {
	field(Handle, static_cast<ManagedType*>(nullptr));

protected:
	using HandleType = const ManagedType*;

public:
	static constexpr auto NullHandle = static_cast<HandleType>(nullptr);

public:
	Owner() = default;
	Owner(ExplicitlyConvertibleTo<HandleType> auto&& Descriptor) {
		auto ManagedHandle = static_cast<HandleType>(Forward(Descriptor));
		this->Handle = Utility::PointerQualifiers::DropAll(ManagedHandle);
	}

public:
	Owner(const Owner& OtherOwner) {
		*this = OtherOwner;
	}
	Owner(Owner&& OtherOwner) {
		*this = std::move(OtherOwner);
	}
	auto& operator=(const Owner& OtherOwner) {
		if (this != &OtherOwner) {
			this->ReleaseHandle();
			this->Handle = OtherOwner.CloneHandle();
		}
		return *this;
	}
	auto& operator=(Owner&& OtherOwner) {
		if (this != &OtherOwner)
			std::swap(this->Handle, OtherOwner.Handle);
		return *this;
	}

public:
	~Owner() {
		this->ReleaseHandle();
	}

public:
	auto IsEmpty() const {
		return Handle == NullHandle;
	}
	auto Leak() {
		auto TransferredHandle = Handle;
		Handle = nullptr;
		return TransferredHandle;
	}
	auto Observe() const {
		return Handle;
	}

protected:
	auto CloneHandle() const {
		if constexpr (SubtypeOf<HandleType, const VSFrameRef*>)
			return Utility::PointerQualifiers::DropAll(VaporGlobals::API->cloneFrameRef(Handle));
		if constexpr (SubtypeOf<HandleType, const VSNodeRef*>)
			return VaporGlobals::API->cloneNodeRef(Handle);
		if constexpr (SubtypeOf<HandleType, const VSFuncRef*>)
			return VaporGlobals::API->cloneFuncRef(Handle);
	}
	auto ReleaseHandle() {
		if constexpr (SubtypeOf<HandleType, const VSFrameRef*>)
			VaporGlobals::API->freeFrame(Handle);
		if constexpr (SubtypeOf<HandleType, const VSNodeRef*>)
			VaporGlobals::API->freeNode(Handle);
		if constexpr (SubtypeOf<HandleType, const VSFuncRef*>)
			VaporGlobals::API->freeFunc(Handle);
	}
};

template<typename ManagedType, auto Managed>
struct ExclusiveOwner {
	field(Handle, static_cast<ManagedType*>(nullptr));

private:
	using HandleType = const ManagedType*;

public:
	ExclusiveOwner() = default;
	ExclusiveOwner(ExplicitlyConvertibleTo<HandleType> auto&& Descriptor) {
		auto ManagedHandle = static_cast<HandleType>(Forward(Descriptor));
		this->Handle = Utility::PointerQualifiers::DropAll(ManagedHandle);
	}

public:
	ExclusiveOwner(const ExclusiveOwner&) = delete;
	ExclusiveOwner(ExclusiveOwner&&) = delete;
	auto& operator=(const ExclusiveOwner&) = delete;
	auto& operator=(ExclusiveOwner&&) = delete;

public:
	~ExclusiveOwner() requires (Managed == false) {
		if (this->Handle != nullptr)
			this->ReleaseHandle();
	}
	~ExclusiveOwner() = default;

public:
	auto Leak() {
		auto TransferredHandle = Handle;
		Handle = nullptr;
		return TransferredHandle;
	}

private:
	auto ReleaseHandle() {
		if constexpr (SubtypeOf<HandleType, const VSMap*>)
			VaporGlobals::API->freeMap(Handle);
		if constexpr (SubtypeOf<HandleType, const VSCore*>)
			VaporGlobals::API->freeCore(Handle);
		if constexpr (auto MangledLoggerID = reinterpret_cast<std::intptr_t>(Handle); SubtypeOf<HandleType, const VSLogHandle*>)
			VaporGlobals::API->removeMessageHandler(~static_cast<int>(MangledLoggerID));
	}
};

struct GarbageCollector {
	using RecyclerType = auto(*)(void*)->void;
	using GarbageRecord = std::tuple<RecyclerType, void*>;

public:
	field(Registry, std::vector<GarbageRecord>{});

public:
	GarbageCollector() = default;

public:
	GarbageCollector(const GarbageCollector&) = delete;
	GarbageCollector(GarbageCollector&&) = delete;
	auto& operator=(const GarbageCollector&) = delete;
	auto& operator=(GarbageCollector&&) = delete;

public:
	~GarbageCollector() {
		for (auto [Recycler, Garbage] : this->Registry)
			Recycler(Garbage);
	}

public:
	auto ClaimOwnership(auto UnmanagedResourceHandle) {
		using ResourceType = std::decay_t<decltype(*UnmanagedResourceHandle)>;
		Registry.push_back({ [](auto ResourcePointer) { delete reinterpret_cast<ResourceType*>(ResourcePointer); }, UnmanagedResourceHandle });
	}
};