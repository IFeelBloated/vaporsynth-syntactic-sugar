#pragma once
#include "VideoNode.vxx"
#include "AudioNode.vxx"
#include "Function.vxx"

template<auto Managed = false>
using MapReference = ExclusiveOwner<VSMap, Managed>;

template<auto Readonly, auto Managed>
struct Item {
	field(Index, 0_ptrdiff);

private:
	struct SharedState : MapReference<Managed> {
		field(Key, ""s);

	public:
		SharedState() = default;
		SharedState(auto&& Descriptor, auto&& Key) : MapReference<Managed>{ Forward(Descriptor) } {
			this->Key = static_cast<std::string>(Forward(Key));
		}
	};

private:
	struct Iterator {
		field(TargetItem, static_cast<const Item*>(nullptr));
		field(Index, 0_ptrdiff);

	public:
		auto operator*() const {
			auto& ItemReference = *TargetItem;
			return ItemReference[Index];
		}
		auto& operator++() {
			++Index;
			return *this;
		}
		auto operator!=(auto&& OtherIterator) const {
			return Index != OtherIterator.Index;
		}
	};

public:
	field(Access, std::shared_ptr<SharedState>{});

public:
	Item() = default;
	Item(auto&& Descriptor, ExplicitlyConvertibleTo<std::string> auto&& Key) {
		this->Access = std::make_shared<SharedState>(Forward(Descriptor), Forward(Key));
	}

public:
	auto Exists() const {
		return Index < size();
	}
	auto Type() const {
		return static_cast<ItemTypes>(VaporGlobals::API->propGetType(Access->Handle, Access->Key.data()));
	}
	auto operator[](IntegralOrEnumerable auto Index) const {
		auto Replica = *this;
		Replica.Index = static_cast<std::ptrdiff_t>(Index);
		return Replica;
	}

public:
	auto size() const {
		return Utility::Max(VaporGlobals::API->propNumElements(Access->Handle, Access->Key.data()), 0);
	}
	auto begin() const {
		return Iterator{ .TargetItem = this, .Index = Index };
	}
	auto end() const {
		return Iterator{ .TargetItem = this, .Index = size() };
	}

public:
	template<std::floating_point TargetType>
	operator TargetType() const {
		return VaporGlobals::API->propGetFloat(Access->Handle, Access->Key.data(), Index, nullptr);
	}

public:
	template<IntegralOrEnumerable TargetType>
	operator TargetType() const {
		return static_cast<TargetType>(VaporGlobals::API->propGetInt(Access->Handle, Access->Key.data(), Index, nullptr));
	}

public:
	template<ConstructibleFrom<const char*> TargetType>
	operator TargetType() const {
		return { VaporGlobals::API->propGetData(Access->Handle, Access->Key.data(), Index, nullptr) };
	}

public:
	template<SubtypeOf<NodeReference> TargetType>
	operator TargetType() const {
		return { VaporGlobals::API->propGetNode(Access->Handle, Access->Key.data(), Index, nullptr) };
	}

public:
	template<SubtypeOf<FrameReference> TargetType>
	operator TargetType() const {
		return { VaporGlobals::API->propGetFrame(Access->Handle, Access->Key.data(), Index, nullptr) };
	}

public:
	template<SubtypeOf<FunctionReference> TargetType>
	operator TargetType() const {
		return { VaporGlobals::API->propGetFunc(Access->Handle, Access->Key.data(), Index, nullptr) };
	}

public:
	template<Iterable TargetType>
	operator TargetType() const requires requires(TargetType x) {
		{ x }->AnyBut<std::initializer_list<std::decay_t<decltype(*x.begin())>>, std::initializer_list<const std::decay_t<decltype(*x.begin())>>>;
		requires (requires { { x }->ConstructibleFrom<const char*>; } == false);
		requires (requires { { x.Type() }->SubtypeOf<ItemTypes>; } == false);
	} {
		auto TargetSequence = TargetType{};
		using ElementType = std::decay_t<decltype(*TargetSequence.begin())>;
		auto ValidateElementType = [] {
			constexpr auto IsNumber = std::floating_point<ElementType> || IntegralOrEnumerable<ElementType>;
			constexpr auto IsString = ConstructibleFrom<ElementType, const char*>;
			constexpr auto IsIntrinsicObject = AnyOf<ElementType, NodeReference, FrameReference, FunctionReference>;
			static_assert(IsNumber || IsString || IsIntrinsicObject, "Item: cannot convert an item to a container of unrecognized type.");
		};
		ValidateElementType();
		if constexpr (auto& Self = *this; requires { TargetSequence.push_back(static_cast<ElementType>(Self)); })
			for (auto&& x : Self)
				TargetSequence.push_back(static_cast<ElementType>(x));
		else if constexpr (requires { TargetSequence.push_front(static_cast<ElementType>(Self)); })
			for (auto x : Range{ size() - 1, -1 })
				TargetSequence.push_front(static_cast<ElementType>(Self[x]));
		else if constexpr (requires { TargetSequence.insert(static_cast<ElementType>(Self)); })
			for (auto&& x : Self)
				TargetSequence.insert(static_cast<ElementType>(x));
		else
			for (auto Cursor = TargetSequence.begin(); auto x : Range{ Utility::Min(size(), std::distance(TargetSequence.begin(), TargetSequence.end())) }) {
				*Cursor = static_cast<ElementType>(Self[x]);
				++Cursor;
			}
		return TargetSequence;
	}

private:
	auto InjectInt(auto Value) const {
		VaporGlobals::API->propSetInt(Access->Handle, Access->Key.data(), static_cast<std::int64_t>(Value), VSPropAppendMode::paAppend);
	}
	auto InjectFloat(auto Value) const {
		VaporGlobals::API->propSetFloat(Access->Handle, Access->Key.data(), Value, VSPropAppendMode::paAppend);
	}
	auto InjectString(auto&& Value) const {
		VaporGlobals::API->propSetData(Access->Handle, Access->Key.data(), Value.data(), Value.size(), VSPropAppendMode::paAppend);
	}
	auto InjectCharArray(auto Value) const {
		VaporGlobals::API->propSetData(Access->Handle, Access->Key.data(), Value, -1, VSPropAppendMode::paAppend);
	}
	auto InjectNode(auto&& Value) const {
		VaporGlobals::API->propSetNode(Access->Handle, Access->Key.data(), Value.Handle, VSPropAppendMode::paAppend);
	}
	auto InjectFrame(auto&& Value) const {
		VaporGlobals::API->propSetFrame(Access->Handle, Access->Key.data(), Value.Handle, VSPropAppendMode::paAppend);
	}
	auto InjectFunction(auto&& Value) const {
		VaporGlobals::API->propSetFunc(Access->Handle, Access->Key.data(), Value.Handle, VSPropAppendMode::paAppend);
	}
	auto InjectDynamicallyTypedObject(auto&& Object) const {
		if (Object.Type() == ItemTypes::Int)
			InjectInt(static_cast<std::int64_t>(Object));
		else if (Object.Type() == ItemTypes::Float)
			InjectFloat(static_cast<double>(Object));
		else if (Object.Type() == ItemTypes::Data)
			InjectString(static_cast<std::string>(Object));
		else if (Object.Type() == ItemTypes::VideoNode || Object.Type() == ItemTypes::AudioNode)
			InjectNode(static_cast<NodeReference>(Object));
		else if (Object.Type() == ItemTypes::VideoFrame || Object.Type() == ItemTypes::AudioFrame)
			InjectFrame(static_cast<FrameReference>(Object));
		else if (Object.Type() == ItemTypes::Function)
			InjectFunction(static_cast<FunctionReference>(Object));
	}

private:
	auto Insert(auto&& Entity, auto AppendMode) const {
		constexpr auto IsIterable = Iterable<decltype(Entity)>;
		constexpr auto IsCharArray = std::convertible_to<decltype(Entity), const char*>;
		constexpr auto IsCharContainer = requires{ { *Entity.begin() }->SubtypeOf<char>; };
		auto InjectValue = [this](auto&& Value) {
			using ValueType = std::decay_t<decltype(Value)>;
			if constexpr (std::floating_point<ValueType>)
				InjectFloat(Value);
			else if constexpr (IntegralOrEnumerable<ValueType>)
				InjectInt(Value);
			else if constexpr (requires { { Value }->ExplicitlyConvertibleTo<const char*>; })
				InjectCharArray(static_cast<const char*>(Value));
			else if constexpr (requires { { Value.size() }->std::integral; { Value.data() }->std::convertible_to<const char*>; })
				InjectString(Value);
			else if constexpr (SubtypeOf<ValueType, NodeReference>)
				InjectNode(Value);
			else if constexpr (SubtypeOf<ValueType, FrameReference>)
				InjectFrame(Value);
			else if constexpr (SubtypeOf<ValueType, FunctionReference>)
				InjectFunction(Value);
			else
				static_assert(sizeof(Value) == -1, "Item: failed to inject an instance of unrecognized type.");
		};
		if (AppendMode == VSPropAppendMode::paReplace)
			Erase();
		if constexpr (requires { { Entity.Type() }->SubtypeOf<ItemTypes>; })
			for (auto&& x : Entity)
				InjectDynamicallyTypedObject(x);
		else if constexpr (IsIterable && !IsCharArray && !IsCharContainer)
			for (auto&& x : Entity)
				InjectValue(x);
		else
			InjectValue(Entity);
	}

public:
	auto Erase() const requires (Readonly == false) {
		return VaporGlobals::API->propDeleteKey(Access->Handle, Access->Key.data()) == 1;
	}
	auto& operator=(AnyBut<Item> auto&& Entity) const requires (Readonly == false) {
		Insert(Entity, VSPropAppendMode::paReplace);
		return *this;
	}
	auto& operator+=(auto&& Entity) const requires (Readonly == false) {
		Insert(Entity, VSPropAppendMode::paAppend);
		return *this;
	}
};

namespace Utility::Map {
	auto Create() {
		return MapReference{ VaporGlobals::API->createMap() };
	}
	auto ListKeys(auto MapHandle) {
		auto ItemCount = VaporGlobals::API->propNumKeys(MapHandle);
		auto Keys = std::vector<std::string_view>{};
		Keys.resize(ItemCount);
		for (auto x : Range{ ItemCount })
			Keys[x] = VaporGlobals::API->propGetKey(MapHandle, x);
		return Keys;
	}
	auto Fill(auto MapHandle, auto&& Key, auto&& Values, auto&& ...Arguments) {
		auto Storage = AccessItem<false>(MapHandle, Forward(Key));
		Storage += Values;
		if constexpr (sizeof...(Arguments) != 0)
			Fill(MapHandle, Forward(Arguments)...);
	}
	auto CheckForError(auto MapHandle) {
		auto ErrorMessage = VaporGlobals::API->getError(MapHandle);
		return std::tuple{ ErrorMessage != nullptr, ErrorMessage };
	}
	auto DeduceReturnKey(auto MapHandle, auto Fallback) {
		if (auto CandidateKeys = ListKeys(MapHandle); CandidateKeys.size() == 1) [[likely]]
			return CandidateKeys[0];
		else
			return Fallback;
	}
	template<auto Readonly, auto Managed>
	auto AccessItem(auto MapHandle, auto&& Key) {
		return Item<Readonly, Managed>{  MapHandle, Forward(Key) };
	}
}

struct ArgumentList {
	field(Handle, static_cast<const VSMap*>(nullptr));

public:
	auto ListSpecifiedParameters() const {
		return Utility::Map::ListKeys(Handle);
	}
	auto operator[](ExplicitlyConvertibleTo<std::string> auto&& Parameter) const {
		return Utility::Map::AccessItem(Handle, Forward(Parameter));
	}
};

struct ConsoleProxy {
	field(Handle, static_cast<VSMap*>(nullptr));

public:
	auto RaiseError(ExplicitlyConvertibleTo<std::string> auto&& FormattedErrorMessage) const {
		auto ErrorMessage = Utility::ExposeCharPointerIfASCIZCompatibleOrDeepCopyIfNot(FormattedErrorMessage);
		VaporGlobals::API->setError(Handle, Utility::ExtractCharPointerFromASCIZFormattedString(ErrorMessage));
	}
};





// anything below this line would be obsolete

template<typename FilterType>
struct Controller {
	field(OutputMap, static_cast<VSMap*>(nullptr));
	auto RaiseError(auto&& ErrorMessage) {
		auto FilterName = std::string{};
		auto Caption = FilterName + ": "s;
		auto DecoratedMessage = Caption + ErrorMessage;
		VaporGlobals::API->setError(OutputMap, ExposeCString(DecoratedMessage));
	}
	auto Receive(auto&& VideoOutput) {
		auto OutputSequence = Utility::Map::AccessItem<false>(OutputMap, "clip");
		OutputSequence += VideoOutput;
	}
	operator auto() {
		return OutputMap;
	}
};