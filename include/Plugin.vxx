#pragma once
#include "Map.vxx"

struct Plugin : PluginInfo {
	field(Handle, static_cast<VSPlugin*>(nullptr));
	field(FilePath, std::filesystem::path{});

private:
	struct Function {
		field(PluginHandle, static_cast<const Plugin*>(nullptr));
		field(Name, ""s);
		field(ParameterList, ""s);

	public:
		auto operator()(auto&& ...Arguments) const requires (sizeof...(Arguments) % 2 == 0) {
			auto ArgumentMap = Utility::Map::Create();
			if constexpr (sizeof...(Arguments) != 0)
				Utility::Map::Fill(ArgumentMap.Handle, Forward(Arguments)...);
			auto ResultMap = VaporGlobals::API->invoke(PluginHandle->Handle, Name.data(), ArgumentMap.Handle);
			auto ResultItem = Utility::Map::AccessItem<true, false>(ResultMap, Utility::Map::DeduceReturnKey(ResultMap, "clip"sv));
			if (auto [EvaluationFailed, ErrorMessage] = Utility::Map::CheckForError(ResultMap); EvaluationFailed)
				throw RuntimeError{ ErrorMessage };
			return ResultItem;
		}
	};

public:
	auto operator[](ExplicitlyConvertibleTo<std::string> auto&& FunctionName) const {
		auto Name = static_cast<std::string>(Forward(FunctionName));
		auto ParameterList = static_cast<std::string>(Utility::Map::AccessItem<true, false>(VaporGlobals::API->getFunctions(Handle), Name)).erase(0, Name.size() + 1);
		return Function{ .PluginHandle = this, .Name = std::move(Name), .ParameterList = std::move(ParameterList) };
	}
	auto ListFunctions() const {
		auto FunctionNames = std::vector<std::string>{};
		for (auto FunctionMap = MapReference{ VaporGlobals::API->getFunctions(Handle) }; auto&& x : Utility::Map::ListKeys(FunctionMap.Handle))
			FunctionNames.push_back(std::string{ x });
		return FunctionNames;
	}
};