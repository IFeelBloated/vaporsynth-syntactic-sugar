#pragma once
#include "Utility.vxx"

template<typename PixelType>
struct CanvasProxy {
	field(Width, 0_size);
	field(Height, 0_size);
	field(Stride, 0_ptrdiff);
	field(Data, static_cast<PixelType*>(nullptr));

public:
	auto operator[](auto y) const {
		return Data + y * Stride;
	}
};

template<typename PixelType>
struct Plane : CanvasProxy<PixelType> {
	static constexpr auto Readonly = std::is_const_v<PixelType>;

private:
	using EmptyType = struct {};
	using CanvasType = CanvasProxy<PixelType>;
	using QuantificationBoundForPaddingFunction = auto(const CanvasType&, std::ptrdiff_t, std::ptrdiff_t)->PixelType;
	using ExistentialTypeForPaddingFunction = std::function<QuantificationBoundForPaddingFunction>;
	using PaddingFunctionProxy = std::conditional_t<Readonly, ExistentialTypeForPaddingFunction, EmptyType>;

public:
	[[no_unique_address]]
	field(PaddingFunction, PaddingFunctionProxy{});

private:
	struct PaddedAccess {
		field(TargetPlane, static_cast<const Plane*>(nullptr));
		field(yAbsolute, 0_ptrdiff);
		field(xOffset, 0_ptrdiff);

	public:
		auto operator[](std::integral auto x) const {
			if (auto xAbsolute = x + xOffset; xAbsolute < 0 || yAbsolute < 0 || xAbsolute >= TargetPlane->Width || yAbsolute >= TargetPlane->Height)
				return TargetPlane->PaddingFunction(TargetPlane->DirectAccess(), yAbsolute, xAbsolute);
			else [[likely]]
				return TargetPlane->DirectAccess()[yAbsolute][xAbsolute];
		}
	};

private:
	struct PlaneView {
		field(TargetPlane, static_cast<const Plane*>(nullptr));
		field(yOffset, 0_ptrdiff);
		field(xOffset, 0_ptrdiff);

	public:
		auto operator[](std::integral auto y) const {
			return PaddedAccess{ .TargetPlane = TargetPlane, .yAbsolute = y + yOffset, .xOffset = xOffset };
		}
		auto GetCoordinates() const {
			return std::array{ yOffset, xOffset };
		}
		auto View(std::integral auto y, std::integral auto x) const {
			return PlaneView{ .TargetPlane = TargetPlane, .yOffset = yOffset + y, .xOffset = xOffset + x };
		}

	public:
		explicit operator auto() const {
			auto StringRepresentation = std::ostringstream{};
			StringRepresentation << "Resolution: " << TargetPlane->Width << " × " << TargetPlane->Height << "\n";
			StringRepresentation << "Absolute Coordinates of the Origin: { y = " << yOffset << ", x = " << xOffset << " }\n";
			StringRepresentation << "Sample Type: " << (std::integral<PixelType> ? "Int" : "Float") << "\n";
			StringRepresentation << "Bytes Per Sample: " << sizeof(PixelType);
			return StringRepresentation.str();
		}
	};

public:
	auto operator[](std::integral auto y) const {
		if constexpr (Readonly)
			return PaddedAccess{ .TargetPlane = this, .yAbsolute = y };
		else
			return CanvasType::operator[](y);
	}
	auto View(std::integral auto y, std::integral auto x) const requires Readonly {
		return PlaneView{ .TargetPlane = this, .yOffset = y, .xOffset = x };
	}
	auto& DirectAccess() const requires Readonly {
		return static_cast<const CanvasType&>(*this);
	}

public:
	explicit operator auto() const {
		auto StringRepresentation = std::ostringstream{};
		StringRepresentation << "Resolution: " << this->Width << " × " << this->Height << "\n";
		StringRepresentation << "Sample Type: " << (std::integral<PixelType> ? "Int" : "Float") << "\n";
		StringRepresentation << "Bytes Per Sample: " << sizeof(PixelType);
		return StringRepresentation.str();
	}
};

namespace PaddingFunctions::Plane {
	auto Constant(auto Value) {
		return [=](auto& Canvas, auto y, auto x) {
			using PixelType = std::decay_t<decltype(Canvas[0][0])>;
			return static_cast<PixelType>(Value);
		};
	}
	auto Repeat = [](auto& Canvas, auto y, auto x) {
		x = Utility::Min(Utility::Max(x, 0), Canvas.Width - 1);
		y = Utility::Min(Utility::Max(y, 0), Canvas.Height - 1);
		return Canvas[y][x];
	};
	auto Reflect = [](auto& Canvas, auto y, auto x) {
		x = Utility::PaddingFunctions::ReflectCoordinate(x, Canvas.Width);
		y = Utility::PaddingFunctions::ReflectCoordinate(y, Canvas.Height);
		return Canvas[y][x];
	};
	auto Zero = Constant(0);
	auto Default = Reflect;
}