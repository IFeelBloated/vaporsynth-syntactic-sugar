#pragma once
#include "Core.vxx"

namespace FilterEngine {
	template<typename FunctionType>
	constexpr auto DeduceFunctionName() {
		auto FunctionSignature = static_cast<std::string>(FunctionType::Signature);
		if (auto FunctionNameLength = FunctionSignature.find("("); FunctionNameLength != std::string::npos)
			return FunctionSignature.substr(0, FunctionNameLength);
		else
			return static_cast<std::string>(Utility::Reflection::ReifyTypeNameIntoString<FunctionType>());
	}

	template<typename FunctionType>
	constexpr auto ExtractParameterList() {
		auto FunctionSignature = static_cast<std::string>(FunctionType::Signature);
		auto ParameterListSector = [&] {
			if (auto SectorMarker = FunctionSignature.find("("); SectorMarker != std::string::npos)
				return SectorMarker + 1;
			else
				return static_cast<decltype(SectorMarker)>(0);
		}();
		auto ReturnKeySector = [&] {
			if (auto SectorMarker = FunctionSignature.find(")"); SectorMarker != std::string::npos)
				return SectorMarker;
			else
				return FunctionSignature.find("->");
		}();
		return FunctionSignature.substr(ParameterListSector, ReturnKeySector == std::string::npos ? ReturnKeySector : ReturnKeySector - ParameterListSector);
	}

	template<typename FunctionType>
	auto DecorateErrorMessage(ExplicitlyConvertibleTo<std::string> auto&& ErrorMessage) {
		return DeduceFunctionName<FunctionType>() + ": " + static_cast<std::string>(Forward(ErrorMessage));
	}

	auto InitiateMetadataSpecifier(auto FilterHandle, auto Core) {
		if constexpr (requires { { FilterHandle->SpecifyMetadata() }->AnyBut<void>; })
			return FilterHandle->SpecifyMetadata();
		else if constexpr (requires { { FilterHandle->SpecifyMetadata(Core) }->AnyBut<void>; })
			return FilterHandle->SpecifyMetadata(Core);
		else
			static_assert(sizeof(FilterHandle) == -1, "FilterEngine: SpecifyMetadata() is either missing or has an incompatible signature.");
	}

	auto OrchestrateMediaTypeDependentActions(auto FilterHandle, auto&& ActionForListOfVideoNodes, auto&& ActionForListOfAudioNodes, auto&& ActionForVideoNode, auto&& ActionForAudioNode) {
		if constexpr ([[maybe_unused]] auto PlaceholderCore = CoreProxy{}; requires { { InitiateMetadataSpecifier(FilterHandle, PlaceholderCore) }->Iterable; })
			if constexpr (requires { { *InitiateMetadataSpecifier(FilterHandle, PlaceholderCore).begin() }->AnyOf<VideoInfo, VSVideoInfo>; })
				return ActionForListOfVideoNodes(FilterHandle);
			else if constexpr (requires { { *InitiateMetadataSpecifier(FilterHandle, PlaceholderCore).begin() }->AnyOf<AudioInfo>; })
				return ActionForListOfAudioNodes(FilterHandle);
			else
				static_assert(sizeof(FilterHandle) == -1, "FilterEngine: failed to decide which action to take because the filter has a list of outputs whose media type cannot be determined.");
		else if constexpr (requires { { InitiateMetadataSpecifier(FilterHandle, PlaceholderCore) }->AnyOf<VideoInfo, VSVideoInfo>; })
			return ActionForVideoNode(FilterHandle);
		else if constexpr (requires { { InitiateMetadataSpecifier(FilterHandle, PlaceholderCore) }->AnyOf<AudioInfo>; })
			return ActionForAudioNode(FilterHandle);
		else
			static_assert(sizeof(FilterHandle) == -1, "FilterEngine: failed to decide which action to take because the media type of the filter's output cannot be determined.");
	}

	auto InitiateFilterInstance(auto FilterInstance, auto ResultMap, auto Core) {
		using FilterType = std::decay_t<decltype(*FilterInstance)>;
		auto FilterName = DeduceFunctionName<FilterType>();
		auto AuxiliaryMap = Utility::Map::Create();
		auto ExecutionPolicy = [&] {
			if constexpr (requires { FilterInstance->SpecifyExecutionPolicy(); })
				if constexpr (requires { { FilterInstance->SpecifyExecutionPolicy() }->AnyOf<ParallelizationSchemes, VSFilterMode>; })
					return static_cast<int>(FilterInstance->SpecifyExecutionPolicy());
				else
					static_assert(sizeof(FilterType) == -1, "FilterEngine: SpecifyExecutionPolicy() has an unrecognized return type.");
			else if constexpr (requires { FilterType::ExecutionPolicy; })
				if constexpr (requires { { FilterType::ExecutionPolicy }->AnyOf<ParallelizationSchemes, VSFilterMode>; })
					return static_cast<int>(FilterType::ExecutionPolicy);
				else
					static_assert(sizeof(FilterType) == -1, "FilterEngine: ExecutionPolicy is of an unrecognized type.");
			else
				return VSFilterMode::fmParallel;
		}();
		auto CachePolicy = [&] {
			if constexpr (requires { FilterInstance->SpecifyCachePolicy(); })
				if constexpr (requires { { FilterInstance->SpecifyCachePolicy() }->AnyOf<CacheOptions, VSNodeFlags>; })
					return static_cast<int>(FilterInstance->SpecifyCachePolicy());
				else
					static_assert(sizeof(FilterType) == -1, "FilterEngine: SpecifyCachePolicy() has an unrecognized return type.");
			else if constexpr (requires { FilterType::CachePolicy; })
				if constexpr (requires { { FilterType::CachePolicy }->AnyOf<CacheOptions, VSNodeFlags>; })
					return static_cast<int>(FilterType::CachePolicy);
				else
					static_assert(sizeof(FilterType) == -1, "FilterEngine: CachePolicy is of an unrecognized type.");
			else
				return static_cast<int>(CacheOptions::Automatic);
		}();
		auto FilterRecycler = [](auto FilterPointer, auto...) {
			auto Garbage = reinterpret_cast<FilterType*>(FilterPointer);
			delete Garbage;
		};
		auto NodeInitializer = [](auto, auto ConsoleHandle, auto FilterPointer, auto NodeHandle, auto CoreHandle, auto...) {
			auto Core = CoreProxy{ .Handle = CoreHandle };
			try {
				OrchestrateMediaTypeDependentActions(reinterpret_cast<FilterType*>(*FilterPointer),
					[&](auto FilterHandle) {
						auto SyncretizedMetadata = std::vector<VSVideoInfo>{};
						for (auto&& x : InitiateMetadataSpecifier(FilterHandle, Core))
							SyncretizedMetadata.push_back(VideoInfo::AdjustToLegacyLayout(x, Core));
						VaporGlobals::API->setVideoInfo(SyncretizedMetadata.data(), SyncretizedMetadata.size(), NodeHandle);
					},
					[](auto) { /* Placeholder for API v4. */ },
					[&](auto FilterHandle) {
						auto Metadata = InitiateMetadataSpecifier(FilterHandle, Core);
						auto&& SyncretizedMetadata = VideoInfo::AdjustToLegacyLayout(Metadata, Core);
						VaporGlobals::API->setVideoInfo(&SyncretizedMetadata, 1, NodeHandle);
					},
					[](auto) { /* Placeholder for API v4. */ }
				);
			}
			catch (RuntimeError& ErrorMessage) {
				auto Console = ConsoleProxy{ .Handle = ConsoleHandle };
				delete reinterpret_cast<FilterType*>(*FilterPointer);
				Console.RaiseError(DecorateErrorMessage<FilterType>(ErrorMessage));
			}
		};
		auto FrameGenerator = [](auto Index, auto ActivationReason, auto FilterPointer, auto AttachmentPointer, auto FrameContextHandle, auto CoreHandle, auto...) {
			auto FrameContext = FrameContextProxy{ .Handle = FrameContextHandle };
			auto InitiateFrameGenerator = [&](auto ...Arguments) {
				if constexpr (auto Core = CoreProxy{ .Handle = CoreHandle }; sizeof...(Arguments) > 1)
					if constexpr (auto [FilterHandle, AttachmentHandle] = std::tuple{ Arguments... }; requires { { FilterHandle->GenerateFrame(Index, FrameContext, *AttachmentHandle, Core) }->SubtypeOf<FrameReference>; })
						return FilterHandle->GenerateFrame(Index, FrameContext, *AttachmentHandle, Core);
					else
						static_assert(sizeof(FilterType) == -1, "FilterEngine: the signature of the frame generator must be \"auto GenerateFrame(auto Index, auto FrameContext, auto& Attachments, auto Core)\" when there're attachments available.");
				else
					if constexpr (auto [FilterHandle] = std::tuple{ Arguments... }; requires { { FilterHandle->GenerateFrame(Index, FrameContext, Core) }->SubtypeOf<FrameReference>; })
						return FilterHandle->GenerateFrame(Index, FrameContext, Core);
					else if constexpr (requires { { FilterHandle->GenerateFrame(Index, Core) }->SubtypeOf<FrameReference>; })
						return FilterHandle->GenerateFrame(Index, Core);
					else if constexpr (requires { { FilterHandle->GenerateFrame(Core) }->SubtypeOf<FrameReference>; })
						return FilterHandle->GenerateFrame(Core);
					else
						static_assert(sizeof(FilterType) == -1, "FilterEngine: GenerateFrame() is either missing or has an incompatible signature.");
			};
			auto InitiateFrameGeneratingSequenceForSourceFilter = [&](auto FilterHandle) {
				if (ActivationReason == VSActivationReason::arInitial)
					return Utility::PointerQualifiers::AddConst(InitiateFrameGenerator(FilterHandle).Leak());
				return Frame::NullHandle;
			};
			auto InitiateFrameGeneratingSequenceForStandardFilter = [&](auto FilterHandle) {
				using AttachmentType = decltype(FilterHandle->AcquireResourcesForFrameGenerator(Index, FrameContext));
				if (auto& AttachmentHandle = reinterpret_cast<AttachmentType*&>(*AttachmentPointer); ActivationReason == VSActivationReason::arInitial)
					if constexpr (requires { { AttachmentHandle }->AnyBut<void*>; })
						AttachmentHandle = new auto{ FilterHandle->AcquireResourcesForFrameGenerator(Index, FrameContext) };
					else
						FilterHandle->AcquireResourcesForFrameGenerator(Index, FrameContext);
				else if (ActivationReason == VSActivationReason::arAllFramesReady)
					if constexpr (requires { { AttachmentHandle }->AnyBut<void*>; }) {
						[[maybe_unused]] auto AttachmentGuard = std::unique_ptr<AttachmentType>{ AttachmentHandle };
						return Utility::PointerQualifiers::AddConst(InitiateFrameGenerator(FilterHandle, AttachmentHandle).Leak());
					}
					else
						return Utility::PointerQualifiers::AddConst(InitiateFrameGenerator(FilterHandle).Leak());
				else if (ActivationReason == VSActivationReason::arError) [[unlikely]]
					if constexpr (requires { { AttachmentHandle }->AnyBut<void*>; })
						delete AttachmentHandle;
				return Frame::NullHandle;
			};
			auto InitiateFrameGeneratingSequenceForFilterRequiringLatentResourceAcquisition = [&](auto FilterHandle) {
				using PrimordialAttachmentType = decltype(FilterHandle->AcquireLatentResources(Index, FrameContext));
				using AttachmentType = decltype(FilterHandle->AcquireResourcesForFrameGenerator(Index, FrameContext));
				static_assert(SubtypeOf<PrimordialAttachmentType, void>, "FilterEngine: sending primordial attachments to AcquireResourcesForFrameGenerator() is not currently supported, open an issue if you have a valid use case that requires this functionality.");
				if (ActivationReason == VSActivationReason::arInitial)
					FilterHandle->AcquireLatentResources(Index, FrameContext);
				else if (auto& AttachmentHandle = reinterpret_cast<AttachmentType*&>(*AttachmentPointer); ActivationReason == VSActivationReason::arAllFramesReady && AttachmentHandle == nullptr)
					if constexpr (requires { { AttachmentHandle }->AnyBut<void*>; })
						AttachmentHandle = new auto{ FilterHandle->AcquireResourcesForFrameGenerator(Index, FrameContext) };
					else
						FilterHandle->AcquireResourcesForFrameGenerator(Index, FrameContext);
				else if (ActivationReason == VSActivationReason::arAllFramesReady)
					if constexpr (requires { { AttachmentHandle }->AnyBut<void*>; }) {
						[[maybe_unused]] auto AttachmentGuard = std::unique_ptr<AttachmentType>{ AttachmentHandle };
						return Utility::PointerQualifiers::AddConst(InitiateFrameGenerator(FilterHandle, AttachmentHandle).Leak());
					}
					else
						return Utility::PointerQualifiers::AddConst(InitiateFrameGenerator(FilterHandle).Leak());
				else if (ActivationReason == VSActivationReason::arError) [[unlikely]]
					if constexpr (requires { { AttachmentHandle }->AnyBut<void*>; })
						delete AttachmentHandle;
				return Frame::NullHandle;
			};
			try {
				if constexpr (auto FilterHandle = reinterpret_cast<FilterType*>(*FilterPointer); requires { FilterHandle->AcquireResourcesForFrameGenerator(Index, FrameContext); })
					if constexpr (requires { FilterHandle->AcquireLatentResources(Index, FrameContext); })
						return InitiateFrameGeneratingSequenceForFilterRequiringLatentResourceAcquisition(FilterHandle);
					else
						return InitiateFrameGeneratingSequenceForStandardFilter(FilterHandle);
				else
					return InitiateFrameGeneratingSequenceForSourceFilter(FilterHandle);
			}
			catch (RuntimeError& ErrorMessage) {
				return FrameContext.RaiseError(DecorateErrorMessage<FilterType>(ErrorMessage));
			}
		};
		OrchestrateMediaTypeDependentActions(FilterInstance.release(),
			[&](auto FilterHandle) { VaporGlobals::API->createFilter(AuxiliaryMap.Handle, ResultMap, FilterName.data(), NodeInitializer, FrameGenerator, FilterRecycler, ExecutionPolicy, CachePolicy, FilterHandle, Core); },
			[](auto) { /* Placeholder for API v4. */ },
			[&](auto FilterHandle) { VaporGlobals::API->createFilter(AuxiliaryMap.Handle, ResultMap, FilterName.data(), NodeInitializer, FrameGenerator, FilterRecycler, ExecutionPolicy, CachePolicy, FilterHandle, Core); },
			[](auto) { /* Placeholder for API v4. */ }
		);
	}

	template<typename FilterType>
	auto FilterInstantiator(auto Arguments, auto Core) {
		if constexpr (requires { FilterType{ Arguments, Core }; })
			return std::make_unique<FilterType>(Arguments, Core);
		else if constexpr (requires { FilterType{ Arguments }; })
			return std::make_unique<FilterType>(Arguments);
		else if constexpr (requires { FilterType{}; })
			return std::make_unique<FilterType>();
		else
			static_assert(sizeof(FilterType) == -1, "FilterEngine: failed to instantiate a filter because its constructor has an incompatible signature.");
	}

	template<typename FilterType>
	auto ImpredicativeFilterInitiator(auto Core) {
		return [=](auto&& ...Arguments) {
			auto ArgumentMap = Utility::Map::Create();
			auto ResultMap = Utility::Map::Create();
			auto ResultItem = Utility::Map::AccessItem(ResultMap.Handle, "clip");
			if constexpr (sizeof...(Arguments) != 0)
				Utility::Map::Fill(ArgumentMap.Handle, Forward(Arguments)...);
			InitiateFilterInstance(FilterInstantiator<FilterType>(ArgumentList{ .Handle = ArgumentMap.Handle }, Core), ResultMap.Handle, Core);
			if (auto [EvaluationFailed, ErrorMessage] = Utility::Map::CheckForError(ResultMap.Handle); EvaluationFailed)
				throw RuntimeError{ ErrorMessage };
			return OrchestrateMediaTypeDependentActions(static_cast<FilterType*>(nullptr),
				[&](auto FilterHandle) {
					using MetadataContainerType = decltype(InitiateMetadataSpecifier(FilterHandle, Core));
					using VideoNodeContainerType = Utility::Reflection::ContainerReplaceElementType<MetadataContainerType, VideoNode>;
					return static_cast<VideoNodeContainerType>(ResultItem);
				},
				[](auto) { /* Placeholder for API v4. */ },
				[&](auto) { return static_cast<VideoNode>(ResultItem); },
				[](auto) { /* Placeholder for API v4. */ }
			);
		};
	}
}

namespace VaporInterface {
	template<typename FilterType>
	auto Create(auto InputMap, auto OutputMap, auto, auto Core, auto...) try {
		auto Data = FilterEngine::FilterInstantiator<FilterType>(ArgumentList{ InputMap }, CoreProxy{ .Handle = Core });
		auto Console = Controller<FilterType>{ OutputMap };
		auto SelfInvoker = FilterEngine::ImpredicativeFilterInitiator<FilterType>(CoreProxy{ .Handle = Core });
		if constexpr (requires { Data->RegisterInvokingSequence(SelfInvoker, CoreProxy{}); })
			Console.Receive(Data->RegisterInvokingSequence(SelfInvoker, CoreProxy{ .Handle = Core }));
		else
			FilterEngine::InitiateFilterInstance(std::move(Data), OutputMap, CoreProxy{ .Handle = Core });
	}
	catch (RuntimeError& ErrorMessage) {
		auto Console = Controller<FilterType>{ OutputMap };
		Console.RaiseError(ErrorMessage);
	}

	template<typename FilterType>
	auto RegisterFilter(auto Broker, auto Plugin) {
		auto FilterName = FilterEngine::DeduceFunctionName<FilterType>();
		auto ParameterList = FilterEngine::ExtractParameterList<FilterType>();
		Broker(FilterName.data(), ParameterList.data(), Create<FilterType>, nullptr, Plugin);
	}

	auto RegisterPlugin(auto Broker, auto Plugin) {
		VaporGlobals::API = getVapourSynthAPI(VAPOURSYNTH_API_VERSION);
		Broker(VaporGlobals::Identifier, VaporGlobals::Namespace, VaporGlobals::Description, VAPOURSYNTH_API_VERSION, 1, Plugin);
	}
}