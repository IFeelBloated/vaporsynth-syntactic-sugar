#pragma once
#include "Core.vxx"

namespace FilterEngine {
	template<typename FunctionType>
	constexpr auto DeduceFunctionName() {
		auto FunctionSignature = static_cast<std::string>(FunctionType::Signature);
		if (auto FunctionNameLength = FunctionSignature.find("("); FunctionNameLength != std::string::npos)
			return FunctionSignature.substr(0, FunctionNameLength);
		else
			return static_cast<std::string>(Utility::Reflection::ReifyTypeNameIntoString<FunctionType>());
	}

	template<typename FunctionType>
	constexpr auto ExtractParameterList() {
		auto FunctionSignature = static_cast<std::string>(FunctionType::Signature);
		auto ParameterListSector = [&] {
			if (auto SectorMarker = FunctionSignature.find("("); SectorMarker != std::string::npos)
				return SectorMarker + 1;
			else
				return static_cast<decltype(SectorMarker)>(0);
		}();
		auto ReturnKeySector = [&] {
			if (auto SectorMarker = FunctionSignature.find(")"); SectorMarker != std::string::npos)
				return SectorMarker;
			else
				return FunctionSignature.find("->");
		}();
		return FunctionSignature.substr(ParameterListSector, ReturnKeySector == std::string::npos ? ReturnKeySector : ReturnKeySector - ParameterListSector);
	}

	template<typename FunctionType>
	auto DecorateErrorMessage(ExplicitlyConvertibleTo<std::string> auto&& ErrorMessage) {
		return DeduceFunctionName<FunctionType>() + ": " + static_cast<std::string>(Forward(ErrorMessage));
	}

	auto InitiateMetadataSpecifier(auto FilterHandle, auto Core) {
		if constexpr (requires { { FilterHandle->SpecifyMetadata() }->AnyBut<void>; })
			return FilterHandle->SpecifyMetadata();
		else if constexpr (requires { { FilterHandle->SpecifyMetadata(Core) }->AnyBut<void>; })
			return FilterHandle->SpecifyMetadata(Core);
		else
			static_assert(sizeof(FilterHandle) == -1, "FilterEngine: SpecifyMetadata() is either missing or has an incompatible signature.");
	}

	auto InitiateFilterInstance(auto FilterHandle, auto ResultMap, auto Core) {
		using FilterType = std::decay_t<decltype(*FilterHandle)>;
		auto FilterName = DeduceFunctionName<FilterType>();
		auto AuxiliaryMap = Utility::Map::Create();
		auto ExecutionPolicy = [&] {
			if constexpr (requires { FilterHandle->SpecifyExecutionPolicy(); })
				if constexpr (requires { { FilterHandle->SpecifyExecutionPolicy() }->AnyOf<ParallelizationSchemes, VSFilterMode>; })
					return static_cast<int>(FilterHandle->SpecifyExecutionPolicy());
				else
					static_assert(sizeof(FilterType) == -1, "FilterEngine: SpecifyExecutionPolicy() has an unrecognized return type.");
			else if constexpr (requires { FilterType::ExecutionPolicy; })
				if constexpr (requires { { FilterType::ExecutionPolicy }->AnyOf<ParallelizationSchemes, VSFilterMode>; })
					return static_cast<int>(FilterType::ExecutionPolicy);
				else
					static_assert(sizeof(FilterType) == -1, "FilterEngine: ExecutionPolicy is of an unrecognized type.");
			else
				return VSFilterMode::fmParallel;
		}();
		auto CachePolicy = [&] {
			if constexpr (requires { FilterHandle->SpecifyCachePolicy(); })
				if constexpr (requires { { FilterHandle->SpecifyCachePolicy() }->AnyOf<CacheOptions, VSNodeFlags>; })
					return static_cast<int>(FilterHandle->SpecifyCachePolicy());
				else
					static_assert(sizeof(FilterType) == -1, "FilterEngine: SpecifyCachePolicy() has an unrecognized return type.");
			else if constexpr (requires { FilterType::CachePolicy; })
				if constexpr (requires { { FilterType::CachePolicy }->AnyOf<CacheOptions, VSNodeFlags>; })
					return static_cast<int>(FilterType::CachePolicy);
				else
					static_assert(sizeof(FilterType) == -1, "FilterEngine: CachePolicy is of an unrecognized type.");
			else
				return static_cast<int>(CacheOptions::Automatic);
		}();
		auto FilterRecycler = [](auto FilterPointer, auto...) {
			auto Garbage = reinterpret_cast<FilterType*>(FilterPointer);
			delete Garbage;
		};
		auto NodeInitializer = [](auto, auto ConsoleHandle, auto FilterPointer, auto NodeHandle, auto CoreHandle, auto...) {
			auto FilterHandle = reinterpret_cast<FilterType*>(*FilterPointer);
			auto Core = CoreProxy{ .Handle = CoreHandle };
			try {
				if constexpr (auto Metadata = InitiateMetadataSpecifier(FilterHandle, Core); requires { { Metadata }->Iterable; })
					if constexpr (requires { { *Metadata.begin() }->AnyOf<VideoInfo, VSVideoInfo>; }) {
						auto SyncretizedMetadata = std::vector<VSVideoInfo>{};
						for (auto&& x : Metadata)
							SyncretizedMetadata.push_back(VideoInfo::AdjustToLegacyLayout(x, Core));
						VaporGlobals::API->setVideoInfo(SyncretizedMetadata.data(), SyncretizedMetadata.size(), NodeHandle);
					}
					else if constexpr (requires { { *Metadata.begin() }->AnyOf<AudioInfo>; })
						//Placeholder for API v4.
						VaporGlobals::API->setVideoInfo(nullptr, 0, nullptr);
					else
						static_assert(sizeof(FilterType) == -1, "FilterEngine: failed to initialize the output node with a container of unrecognized metadata type.");
				else if constexpr (requires { { Metadata }->AnyOf<VideoInfo, VSVideoInfo>; }) {
					auto&& SyncretizedMetadata = VideoInfo::AdjustToLegacyLayout(Metadata, Core);
					VaporGlobals::API->setVideoInfo(&SyncretizedMetadata, 1, NodeHandle);
				}
				else if constexpr (requires { { Metadata }->AnyOf<AudioInfo>; })
					//Placeholder for API v4.
					VaporGlobals::API->setVideoInfo(nullptr, 0, nullptr);
				else
					static_assert(sizeof(FilterType) == -1, "FilterEngine: failed to initialize the output node with metadata of unrecognized type.");
			}
			catch (RuntimeError& ErrorMessage) {
				auto Console = ConsoleProxy{ .Handle = ConsoleHandle };
				delete FilterHandle;
				Console.RaiseError(DecorateErrorMessage<FilterType>(ErrorMessage));
			}
		};
		auto FrameGenerator = [](auto Index, auto ActivationReason, auto FilterPointer, auto AttachmentPointer, auto FrameContextHandle, auto CoreHandle, auto...) {
			auto FrameContext = FrameContextProxy{ .Handle = FrameContextHandle };
			auto InitiateFrameGenerator = [&](auto ...Arguments) {
				if constexpr (auto Core = CoreProxy{ .Handle = CoreHandle }; sizeof...(Arguments) > 1)
					if constexpr (auto [FilterHandle, AttachmentHandle] = std::tuple{ Arguments... }; requires { { FilterHandle->GenerateFrame(Index, FrameContext, *AttachmentHandle, Core) }->SubtypeOf<FrameReference>; })
						return FilterHandle->GenerateFrame(Index, FrameContext, *AttachmentHandle, Core);
					else
						static_assert(sizeof(FilterType) == -1, "FilterEngine: the signature of the frame generator must be \"auto GenerateFrame(auto Index, auto FrameContext, auto& Attachments, auto Core)\" when there're attachments available.");
				else
					if constexpr (auto [FilterHandle] = std::tuple{ Arguments... }; requires { { FilterHandle->GenerateFrame(Index, FrameContext, Core) }->SubtypeOf<FrameReference>; })
						return FilterHandle->GenerateFrame(Index, FrameContext, Core);
					else if constexpr (requires { { FilterHandle->GenerateFrame(Index, Core) }->SubtypeOf<FrameReference>; })
						return FilterHandle->GenerateFrame(Index, Core);
					else if constexpr (requires { { FilterHandle->GenerateFrame(Core) }->SubtypeOf<FrameReference>; })
						return FilterHandle->GenerateFrame(Core);
					else
						static_assert(sizeof(FilterType) == -1, "FilterEngine: GenerateFrame() is either missing or has an incompatible signature.");
			};
			auto InitiateFrameGeneratingSequenceForSourceFilter = [&](auto FilterHandle) {
				if (ActivationReason == VSActivationReason::arInitial)
					return Utility::PointerQualifiers::AddConst(InitiateFrameGenerator(FilterHandle).Leak());
				return Frame::NullHandle;
			};
			auto InitiateFrameGeneratingSequenceForStandardFilter = [&](auto FilterHandle) {
				using AttachmentType = decltype(FilterHandle->AcquireResourcesForFrameGenerator(Index, FrameContext));
				if (auto& AttachmentHandle = reinterpret_cast<AttachmentType*&>(*AttachmentPointer); ActivationReason == VSActivationReason::arInitial)
					if constexpr (requires { { AttachmentHandle }->AnyBut<void*>; })
						AttachmentHandle = new auto{ FilterHandle->AcquireResourcesForFrameGenerator(Index, FrameContext) };
					else
						FilterHandle->AcquireResourcesForFrameGenerator(Index, FrameContext);
				else if (ActivationReason == VSActivationReason::arAllFramesReady)
					if constexpr (requires { { AttachmentHandle }->AnyBut<void*>; }) {
						[[maybe_unused]] auto AttachmentGuard = std::unique_ptr<AttachmentType>{ AttachmentHandle };
						return Utility::PointerQualifiers::AddConst(InitiateFrameGenerator(FilterHandle, AttachmentHandle).Leak());
					}
					else
						return Utility::PointerQualifiers::AddConst(InitiateFrameGenerator(FilterHandle).Leak());
				else if (ActivationReason == VSActivationReason::arError) [[unlikely]]
					if constexpr (requires { { AttachmentHandle }->AnyBut<void*>; })
						delete AttachmentHandle;
				return Frame::NullHandle;
			};
			auto InitiateFrameGeneratingSequenceForFilterRequiringLatentResourceAcquisition = [&](auto FilterHandle) {
				using PrimordialAttachmentType = decltype(FilterHandle->AcquireLatentResources(Index, FrameContext));
				using AttachmentType = decltype(FilterHandle->AcquireResourcesForFrameGenerator(Index, FrameContext));
				static_assert(SubtypeOf<PrimordialAttachmentType, void>, "FilterEngine: sending primordial attachments to AcquireResourcesForFrameGenerator() is not currently supported, open an issue if you have a valid use case that requires this functionality.");
				if (ActivationReason == VSActivationReason::arInitial)
					FilterHandle->AcquireLatentResources(Index, FrameContext);
				else if (auto& AttachmentHandle = reinterpret_cast<AttachmentType*&>(*AttachmentPointer); ActivationReason == VSActivationReason::arAllFramesReady && AttachmentHandle == nullptr)
					if constexpr (requires { { AttachmentHandle }->AnyBut<void*>; })
						AttachmentHandle = new auto{ FilterHandle->AcquireResourcesForFrameGenerator(Index, FrameContext) };
					else
						FilterHandle->AcquireResourcesForFrameGenerator(Index, FrameContext);
				else if (ActivationReason == VSActivationReason::arAllFramesReady)
					if constexpr (requires { { AttachmentHandle }->AnyBut<void*>; }) {
						[[maybe_unused]] auto AttachmentGuard = std::unique_ptr<AttachmentType>{ AttachmentHandle };
						return Utility::PointerQualifiers::AddConst(InitiateFrameGenerator(FilterHandle, AttachmentHandle).Leak());
					}
					else
						return Utility::PointerQualifiers::AddConst(InitiateFrameGenerator(FilterHandle).Leak());
				else if (ActivationReason == VSActivationReason::arError) [[unlikely]]
					if constexpr (requires { { AttachmentHandle }->AnyBut<void*>; })
						delete AttachmentHandle;
				return Frame::NullHandle;
			};
			try {
				if constexpr (auto FilterHandle = reinterpret_cast<FilterType*>(*FilterPointer); requires { FilterHandle->AcquireResourcesForFrameGenerator(Index, FrameContext); })
					if constexpr (requires { FilterHandle->AcquireLatentResources(Index, FrameContext); })
						return InitiateFrameGeneratingSequenceForFilterRequiringLatentResourceAcquisition(FilterHandle);
					else
						return InitiateFrameGeneratingSequenceForStandardFilter(FilterHandle);
				else
					return InitiateFrameGeneratingSequenceForSourceFilter(FilterHandle);
			}
			catch (RuntimeError& ErrorMessage) {
				return FrameContext.RaiseError(DecorateErrorMessage<FilterType>(ErrorMessage));
			}
		};
		if constexpr (requires { { InitiateMetadataSpecifier(FilterHandle, Core) }->Iterable; })
			if constexpr (requires { { *InitiateMetadataSpecifier(FilterHandle, Core).begin() }->AnyOf<VideoInfo, VSVideoInfo>; })
				VaporGlobals::API->createFilter(AuxiliaryMap.Handle, ResultMap, FilterName.data(), NodeInitializer, FrameGenerator, FilterRecycler, ExecutionPolicy, CachePolicy, FilterHandle, Core);
			else if constexpr (requires { { *InitiateMetadataSpecifier(FilterHandle, Core).begin() }->AnyOf<AudioInfo>; })
				//Placeholder for API v4.
				VaporGlobals::API->createFilter(nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, 0, 0, nullptr, nullptr);
			else
				static_assert(sizeof(FilterType) == -1, "FilterEngine: failed to initiate a filter with a list of outputs of unrecognized media type.");
		else if constexpr (requires { { InitiateMetadataSpecifier(FilterHandle, Core) }->AnyOf<VideoInfo, VSVideoInfo>; })
			VaporGlobals::API->createFilter(AuxiliaryMap.Handle, ResultMap, FilterName.data(), NodeInitializer, FrameGenerator, FilterRecycler, ExecutionPolicy, CachePolicy, FilterHandle, Core);
		else if constexpr (requires { { InitiateMetadataSpecifier(FilterHandle, Core) }->AnyOf<AudioInfo>; })
			//Placeholder for API v4.
			VaporGlobals::API->createFilter(nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, 0, 0, nullptr, nullptr);
		else
			static_assert(sizeof(FilterType) == -1, "FilterEngine: failed to initiate a filter with an output of unrecognized media type.");
	}
}

namespace VaporInterface {
	template<typename FilterType>
	auto Create(auto InputMap, auto OutputMap, auto, auto Core, auto...) try {
		auto Data = [&] {
			if constexpr (requires { FilterType{ ArgumentList{} }; })
				return FilterType{ ArgumentList{ InputMap } };
			else
				return FilterType{ ArgumentList{ InputMap }, CoreProxy{ .Handle = Core } };
		}();
		auto Console = Controller<FilterType>{ OutputMap };
		auto SelfInvoker = [&](auto&& ...Arguments) {
			auto InstanceData = static_cast<FilterType*>(nullptr);
			auto ArgumentMap = VaporGlobals::API->createMap();
			auto EvaluatedMap = VaporGlobals::API->createMap();
			auto MaterializeEvaluatedClips = [&]() {
				if constexpr (requires { InstanceData->SpecifyMetadata(CoreProxy{}); }) {
					using VideoInfoType = decltype(InstanceData->SpecifyMetadata(CoreProxy{}));
					auto VideoInfoPrototype = VideoInfoType{};
					if constexpr (WithConstexprSize(VideoInfoPrototype))
						return ExtractEvaluatedClips<true, VideoInfoPrototype.size()>(EvaluatedMap);
					else
						return ExtractEvaluatedClips<requires { VideoInfoPrototype.size(); }, IndeterminateSize>(EvaluatedMap);
				}
				else if constexpr (requires { InstanceData->SpecifyMetadata(); }) {
					using VideoInfoType = decltype(InstanceData->SpecifyMetadata());
					auto VideoInfoPrototype = VideoInfoType{};
					if constexpr (WithConstexprSize(VideoInfoPrototype))
						return ExtractEvaluatedClips<true, VideoInfoPrototype.size()>(EvaluatedMap);
					else
						return ExtractEvaluatedClips<requires { VideoInfoPrototype.size(); }, IndeterminateSize>(EvaluatedMap);
				}
				else
					return ExtractEvaluatedClips<true, IndeterminateSize>(EvaluatedMap);
			};
			if constexpr (sizeof...(Arguments) != 0)
				Utility::Map::Fill(ArgumentMap, Forward(Arguments)...);
			try {
				if constexpr (requires { FilterType{ ArgumentList{} }; })
					InstanceData = new FilterType{ ArgumentList{ ArgumentMap } };
				else
					InstanceData = new FilterType{ ArgumentList{ ArgumentMap }, CoreProxy{ .Handle = Core } };
			}
			catch (...) {
				VaporGlobals::API->freeMap(EvaluatedMap);
				VaporGlobals::API->freeMap(ArgumentMap);
				throw;
			}
			FilterEngine::InitiateFilterInstance(InstanceData, EvaluatedMap, CoreProxy{ .Handle = Core });
			auto EvaluatedClips = MaterializeEvaluatedClips();
			VaporGlobals::API->freeMap(EvaluatedMap);
			VaporGlobals::API->freeMap(ArgumentMap);
			return EvaluatedClips;
		};
		if constexpr (requires { Data.RegisterInvokingSequence(SelfInvoker, CoreProxy{}); })
			Console.Receive(Data.RegisterInvokingSequence(SelfInvoker, CoreProxy{ .Handle = Core }));
		else
			FilterEngine::InitiateFilterInstance(new FilterType{ std::move(Data) }, OutputMap, CoreProxy{ .Handle = Core });
	}
	catch (RuntimeError& ErrorMessage) {
		auto Console = Controller<FilterType>{ OutputMap };
		Console.RaiseError(ErrorMessage);
	}

	template<typename FilterType>
	auto RegisterFilter(auto Broker, auto Plugin) {
		auto FilterName = FilterEngine::DeduceFunctionName<FilterType>();
		auto ParameterList = FilterEngine::ExtractParameterList<FilterType>();
		Broker(FilterName.data(), ParameterList.data(), Create<FilterType>, nullptr, Plugin);
	}

	auto RegisterPlugin(auto Broker, auto Plugin) {
		VaporGlobals::API = getVapourSynthAPI(VAPOURSYNTH_API_VERSION);
		Broker(VaporGlobals::Identifier, VaporGlobals::Namespace, VaporGlobals::Description, VAPOURSYNTH_API_VERSION, 1, Plugin);
	}
}